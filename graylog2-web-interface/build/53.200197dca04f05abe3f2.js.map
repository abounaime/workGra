{"version":3,"sources":["webpack:///53.200197dca04f05abe3f2.js","webpack:///./src/pages/SearchPage.jsx"],"names":["webpackJsonp","1400","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_react","_react2","_reflux","_reflux2","_immutable","_immutable2","_moment","_moment2","_CombinedProvider","_CombinedProvider2","_common","_search","_CombinedProvider$get","get","NodesStore","NodesActions","_CombinedProvider$get2","CurrentUserStore","_CombinedProvider$get3","InputsStore","InputsActions","_CombinedProvider$get4","MessageFieldsStore","_CombinedProvider$get5","RefreshStore","_CombinedProvider$get6","StreamsStore","_CombinedProvider$get7","UniversalSearchStore","_CombinedProvider$get8","SearchStore","_CombinedProvider$get9","DecoratorsStore","SearchPage","createClass","displayName","propTypes","location","PropTypes","object","isRequired","searchConfig","searchInStream","forceFetch","bool","mixins","connect","listenTo","getInitialState","error","undefined","updatingSearch","updatingHistogram","componentDidMount","_this","this","list","triggerPromise","listStreams","then","streams","streamsMap","forEach","stream","id","setState","Map","componentWillReceiveProps","nextProps","props","search","promise","cancel","_refreshData","componentWillUnmount","_stopTimer","_setupTimer","refresh","enabled","timer","setInterval","interval","clearInterval","_refreshDataFromDecoratorStore","_this2","query","originalQuery","streamId","isCancelled","parseInt","originalRangeType","originalRangeParams","toJS","page","sortField","sortOrder","response","isMounted","searchResult","_determineHistogramResolution","histogram","finally","additional","status","_formatInputs","state","inputs","inputsAsMap","_determineSearchDuration","searchTo","to","searchFrom","sortedIndices","used_indices","sort","i1","i2","end","oldestIndex","valueOf","begin","from","queryRangeInMinutes","diff","duration","asHours","asDays","asMonths","asYears","_isLoading","nodes","fields","render","errorPage","createElement","MalformedSearchQuery","SearchExecutionError","DocumentTitle","title","Spinner","all_fields","SearchResult","builtQuery","built_query","result","formattedHistogram","permissions","currentUser","loadingSearch"],"mappings":"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","file":"53.200197dca04f05abe3f2.js","sourcesContent":["webpackJsonp([53],{\n\n/***/ 1400:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _react = __webpack_require__(2);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reflux = __webpack_require__(1);\n\nvar _reflux2 = _interopRequireDefault(_reflux);\n\nvar _immutable = __webpack_require__(55);\n\nvar _immutable2 = _interopRequireDefault(_immutable);\n\nvar _moment = __webpack_require__(34);\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _CombinedProvider = __webpack_require__(86);\n\nvar _CombinedProvider2 = _interopRequireDefault(_CombinedProvider);\n\nvar _common = __webpack_require__(48);\n\nvar _search = __webpack_require__(966);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _CombinedProvider$get = _CombinedProvider2.default.get('Nodes'),\n    NodesStore = _CombinedProvider$get.NodesStore,\n    NodesActions = _CombinedProvider$get.NodesActions;\n\nvar _CombinedProvider$get2 = _CombinedProvider2.default.get('CurrentUser'),\n    CurrentUserStore = _CombinedProvider$get2.CurrentUserStore;\n\nvar _CombinedProvider$get3 = _CombinedProvider2.default.get('Inputs'),\n    InputsStore = _CombinedProvider$get3.InputsStore,\n    InputsActions = _CombinedProvider$get3.InputsActions;\n\nvar _CombinedProvider$get4 = _CombinedProvider2.default.get('MessageFields'),\n    MessageFieldsStore = _CombinedProvider$get4.MessageFieldsStore;\n\nvar _CombinedProvider$get5 = _CombinedProvider2.default.get('Refresh'),\n    RefreshStore = _CombinedProvider$get5.RefreshStore;\n\nvar _CombinedProvider$get6 = _CombinedProvider2.default.get('Streams'),\n    StreamsStore = _CombinedProvider$get6.StreamsStore;\n\nvar _CombinedProvider$get7 = _CombinedProvider2.default.get('UniversalSearch'),\n    UniversalSearchStore = _CombinedProvider$get7.UniversalSearchStore;\n\nvar _CombinedProvider$get8 = _CombinedProvider2.default.get('Search'),\n    SearchStore = _CombinedProvider$get8.SearchStore;\n\nvar _CombinedProvider$get9 = _CombinedProvider2.default.get('Decorators'),\n    DecoratorsStore = _CombinedProvider$get9.DecoratorsStore;\n\nvar SearchPage = _react2.default.createClass({\n  displayName: 'SearchPage',\n\n  propTypes: {\n    location: _react.PropTypes.object.isRequired,\n    searchConfig: _react.PropTypes.object.isRequired,\n    searchInStream: _react.PropTypes.object,\n    forceFetch: _react.PropTypes.bool\n  },\n  mixins: [_reflux2.default.connect(NodesStore), _reflux2.default.connect(MessageFieldsStore), _reflux2.default.connect(CurrentUserStore), _reflux2.default.listenTo(InputsStore, '_formatInputs'), _reflux2.default.listenTo(RefreshStore, '_setupTimer', '_setupTimer'), _reflux2.default.listenTo(DecoratorsStore, '_refreshDataFromDecoratorStore', '_refreshDataFromDecoratorStore')],\n  getInitialState: function getInitialState() {\n    return {\n      error: undefined,\n      updatingSearch: false,\n      updatingHistogram: false\n    };\n  },\n  componentDidMount: function componentDidMount() {\n    var _this = this;\n\n    InputsActions.list.triggerPromise();\n\n    StreamsStore.listStreams().then(function (streams) {\n      var streamsMap = {};\n      streams.forEach(function (stream) {\n        streamsMap[stream.id] = stream;\n      });\n      _this.setState({ streams: _immutable2.default.Map(streamsMap) });\n    });\n\n    NodesActions.list();\n  },\n  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n    var currentLocation = this.props.location || {};\n    var nextLocation = nextProps.location || {};\n\n    if (currentLocation.search !== nextLocation.search || this.props.searchInStream !== nextProps.searchInStream || nextProps.forceFetch) {\n      if (this.promise) {\n        this.promise.cancel();\n      }\n      this._refreshData(nextProps.searchInStream);\n    }\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    this._stopTimer();\n  },\n  _setupTimer: function _setupTimer(refresh) {\n    this._stopTimer();\n    if (refresh.enabled) {\n      this.timer = setInterval(this._refreshData, refresh.interval);\n    }\n  },\n  _stopTimer: function _stopTimer() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n  },\n  _refreshDataFromDecoratorStore: function _refreshDataFromDecoratorStore() {\n    var searchInStream = this.props.searchInStream;\n    this._refreshData(searchInStream);\n  },\n  _refreshData: function _refreshData(searchInStream) {\n    var _this2 = this;\n\n    var query = SearchStore.originalQuery;\n    var stream = searchInStream || this.props.searchInStream || {};\n    var streamId = stream.id;\n    if (this.promise && !this.promise.isCancelled()) {\n      return this.promise;\n    }\n    if (!RefreshStore.enabled || RefreshStore.enabled && parseInt(RefreshStore.interval) > 5000) {\n      this.setState({ updatingSearch: true });\n    }\n    this.promise = UniversalSearchStore.search(SearchStore.originalRangeType, query, SearchStore.originalRangeParams.toJS(), streamId, null, SearchStore.page, SearchStore.sortField, SearchStore.sortOrder).then(function (response) {\n      if (_this2.isMounted()) {\n        _this2.setState({ searchResult: response, error: undefined });\n      }\n\n      var interval = _this2.props.location.query.interval ? _this2.props.location.query.interval : _this2._determineHistogramResolution(response);\n\n      if (!RefreshStore.enabled || RefreshStore.enabled && parseInt(RefreshStore.interval) > 5000) {\n        _this2.setState({ updatingHistogram: true });\n      }\n      UniversalSearchStore.histogram(SearchStore.originalRangeType, query, SearchStore.originalRangeParams.toJS(), interval, streamId).then(function (histogram) {\n        _this2.setState({ histogram: histogram });\n        return histogram;\n      }).finally(function () {\n        return _this2.setState({ updatingHistogram: false });\n      });\n\n      return response;\n    }, function (error) {\n      // Treat searches with a malformed query\n      if (error.additional) {\n        if (error.additional.status) {\n          _this2.setState({ error: error.additional });\n        }\n      }\n    }).finally(function () {\n      _this2.setState({ updatingSearch: false });\n      _this2.promise = undefined;\n    });\n  },\n  _formatInputs: function _formatInputs(state) {\n    var inputs = InputsStore.inputsAsMap(state.inputs);\n    this.setState({ inputs: _immutable2.default.Map(inputs) });\n  },\n  _determineSearchDuration: function _determineSearchDuration(response) {\n    var searchTo = response.to;\n    var searchFrom = void 0;\n    if (SearchStore.originalRangeType === 'relative' && SearchStore.originalRangeParams.get('relative') === 0) {\n      var sortedIndices = response.used_indices.sort(function (i1, i2) {\n        return (0, _moment2.default)(i1.end) - (0, _moment2.default)(i2.end);\n      });\n      // If we didn't calculate index ranges for the oldest index, pick the next one.\n      // This usually happens to the deflector, when index ranges weren't calculated for it yet.\n      var oldestIndex = (0, _moment2.default)(sortedIndices[0].end).valueOf() === 0 ? sortedIndices[1] : sortedIndices[0];\n\n      if (oldestIndex !== undefined) {\n        searchFrom = oldestIndex.begin;\n      } else {\n        // We don't know when we received the first message, assume the search duration is 0.\n        searchFrom = searchTo;\n      }\n    } else {\n      searchFrom = response.from;\n    }\n\n    var queryRangeInMinutes = (0, _moment2.default)(searchTo).diff(searchFrom, 'minutes');\n\n    return _moment2.default.duration(queryRangeInMinutes, 'minutes');\n  },\n  _determineHistogramResolution: function _determineHistogramResolution(response) {\n    var duration = this._determineSearchDuration(response);\n\n    if (duration.asHours() < 12) {\n      return 'minute';\n    }\n\n    if (duration.asDays() < 3) {\n      return 'hour';\n    }\n\n    if (duration.asDays() < 30) {\n      return 'day';\n    }\n\n    if (duration.asMonths() < 2) {\n      return 'week';\n    }\n\n    if (duration.asMonths() < 18) {\n      return 'month';\n    }\n\n    if (duration.asYears() < 3) {\n      return 'quarter';\n    }\n\n    return 'year';\n  },\n  _isLoading: function _isLoading() {\n    return !this.state.searchResult || !this.state.inputs || !this.state.streams || !this.state.nodes || !this.state.fields || !this.state.histogram;\n  },\n  render: function render() {\n    if (this.state.error) {\n      var errorPage = void 0;\n      switch (this.state.error.status) {\n        case 400:\n          errorPage = _react2.default.createElement(_search.MalformedSearchQuery, { error: this.state.error });\n          break;\n        default:\n          errorPage = _react2.default.createElement(_search.SearchExecutionError, { error: this.state.error });\n      }\n\n      return _react2.default.createElement(\n        _common.DocumentTitle,\n        { title: 'Search error' },\n        errorPage\n      );\n    }\n\n    if (this._isLoading()) {\n      return _react2.default.createElement(_common.Spinner, null);\n    }\n\n    var searchResult = this.state.searchResult;\n    searchResult.all_fields = this.state.fields;\n    return _react2.default.createElement(\n      _common.DocumentTitle,\n      { title: 'Search' },\n      _react2.default.createElement(_search.SearchResult, { query: SearchStore.originalQuery, page: SearchStore.page, builtQuery: searchResult.built_query,\n        result: searchResult, histogram: this.state.histogram,\n        formattedHistogram: this.state.histogram.histogram,\n        streams: this.state.streams, inputs: this.state.inputs, nodes: _immutable2.default.Map(this.state.nodes),\n        searchInStream: this.props.searchInStream, permissions: this.state.currentUser.permissions,\n        searchConfig: this.props.searchConfig,\n        loadingSearch: this.state.updatingSearch || this.state.updatingHistogram,\n        forceFetch: this.props.forceFetch })\n    );\n  }\n});\n\nexports.default = SearchPage;\nmodule.exports = exports['default'];\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 53.200197dca04f05abe3f2.js","import React, { PropTypes } from 'react';\nimport Reflux from 'reflux';\nimport Immutable from 'immutable';\nimport moment from 'moment';\n\nimport CombinedProvider from 'injection/CombinedProvider';\nconst { NodesStore, NodesActions } = CombinedProvider.get('Nodes');\nconst { CurrentUserStore } = CombinedProvider.get('CurrentUser');\nconst { InputsStore, InputsActions } = CombinedProvider.get('Inputs');\nconst { MessageFieldsStore } = CombinedProvider.get('MessageFields');\nconst { RefreshStore } = CombinedProvider.get('Refresh');\nconst { StreamsStore } = CombinedProvider.get('Streams');\nconst { UniversalSearchStore } = CombinedProvider.get('UniversalSearch');\nconst { SearchStore } = CombinedProvider.get('Search');\nconst { DecoratorsStore } = CombinedProvider.get('Decorators');\n\nimport { DocumentTitle, Spinner } from 'components/common';\nimport { MalformedSearchQuery, SearchExecutionError, SearchResult } from 'components/search';\n\nconst SearchPage = React.createClass({\n  propTypes: {\n    location: PropTypes.object.isRequired,\n    searchConfig: PropTypes.object.isRequired,\n    searchInStream: PropTypes.object,\n    forceFetch: PropTypes.bool,\n  },\n  mixins: [\n    Reflux.connect(NodesStore),\n    Reflux.connect(MessageFieldsStore),\n    Reflux.connect(CurrentUserStore),\n    Reflux.listenTo(InputsStore, '_formatInputs'),\n    Reflux.listenTo(RefreshStore, '_setupTimer', '_setupTimer'),\n    Reflux.listenTo(DecoratorsStore, '_refreshDataFromDecoratorStore', '_refreshDataFromDecoratorStore'),\n  ],\n  getInitialState() {\n    return {\n      error: undefined,\n      updatingSearch: false,\n      updatingHistogram: false,\n    };\n  },\n  componentDidMount() {\n    InputsActions.list.triggerPromise();\n\n    StreamsStore.listStreams().then((streams) => {\n      const streamsMap = {};\n      streams.forEach((stream) => { streamsMap[stream.id] = stream; });\n      this.setState({ streams: Immutable.Map(streamsMap) });\n    });\n\n    NodesActions.list();\n  },\n  componentWillReceiveProps(nextProps) {\n    const currentLocation = this.props.location || {};\n    const nextLocation = nextProps.location || {};\n\n    if (currentLocation.search !== nextLocation.search || this.props.searchInStream !== nextProps.searchInStream || nextProps.forceFetch) {\n      if (this.promise) {\n        this.promise.cancel();\n      }\n      this._refreshData(nextProps.searchInStream);\n    }\n  },\n  componentWillUnmount() {\n    this._stopTimer();\n  },\n  _setupTimer(refresh) {\n    this._stopTimer();\n    if (refresh.enabled) {\n      this.timer = setInterval(this._refreshData, refresh.interval);\n    }\n  },\n  _stopTimer() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n  },\n  _refreshDataFromDecoratorStore() {\n    const searchInStream = this.props.searchInStream;\n    this._refreshData(searchInStream);\n  },\n  _refreshData(searchInStream) {\n    const query = SearchStore.originalQuery;\n    const stream = searchInStream || this.props.searchInStream || {};\n    const streamId = stream.id;\n    if (this.promise && !this.promise.isCancelled()) {\n      return this.promise;\n    }\n    if (!RefreshStore.enabled || RefreshStore.enabled && parseInt(RefreshStore.interval) > 5000) {\n      this.setState({ updatingSearch: true });\n    }\n    this.promise = UniversalSearchStore.search(SearchStore.originalRangeType, query, SearchStore.originalRangeParams.toJS(), streamId, null, SearchStore.page, SearchStore.sortField, SearchStore.sortOrder)\n      .then(\n        (response) => {\n          if (this.isMounted()) {\n            this.setState({ searchResult: response, error: undefined });\n          }\n\n          const interval = this.props.location.query.interval ? this.props.location.query.interval : this._determineHistogramResolution(response);\n\n          if (!RefreshStore.enabled || RefreshStore.enabled && parseInt(RefreshStore.interval) > 5000) {\n             this.setState({ updatingHistogram: true });\n          }\n          UniversalSearchStore.histogram(SearchStore.originalRangeType, query, SearchStore.originalRangeParams.toJS(), interval, streamId)\n            .then((histogram) => {\n              this.setState({ histogram: histogram });\n              return histogram;\n            })\n            .finally(() => this.setState({ updatingHistogram: false }));\n\n          return response;\n        },\n        (error) => {\n          // Treat searches with a malformed query\n          if (error.additional) {\n            if (error.additional.status) {\n              this.setState({ error: error.additional });\n            }\n          }\n        },\n      )\n      .finally(() => {\n        this.setState({ updatingSearch: false });\n        this.promise = undefined;\n      });\n  },\n  _formatInputs(state) {\n    const inputs = InputsStore.inputsAsMap(state.inputs);\n    this.setState({ inputs: Immutable.Map(inputs) });\n  },\n  _determineSearchDuration(response) {\n    const searchTo = response.to;\n    let searchFrom;\n    if (SearchStore.originalRangeType === 'relative' && SearchStore.originalRangeParams.get('relative') === 0) {\n      const sortedIndices = response.used_indices.sort((i1, i2) => moment(i1.end) - moment(i2.end));\n      // If we didn't calculate index ranges for the oldest index, pick the next one.\n      // This usually happens to the deflector, when index ranges weren't calculated for it yet.\n      const oldestIndex = moment(sortedIndices[0].end).valueOf() === 0 ? sortedIndices[1] : sortedIndices[0];\n\n      if (oldestIndex !== undefined) {\n        searchFrom = oldestIndex.begin;\n      } else {\n        // We don't know when we received the first message, assume the search duration is 0.\n        searchFrom = searchTo;\n      }\n    } else {\n      searchFrom = response.from;\n    }\n\n    const queryRangeInMinutes = moment(searchTo).diff(searchFrom, 'minutes');\n\n    return moment.duration(queryRangeInMinutes, 'minutes');\n  },\n  _determineHistogramResolution(response) {\n    const duration = this._determineSearchDuration(response);\n\n    if (duration.asHours() < 12) {\n      return 'minute';\n    }\n\n    if (duration.asDays() < 3) {\n      return 'hour';\n    }\n\n    if (duration.asDays() < 30) {\n      return 'day';\n    }\n\n    if (duration.asMonths() < 2) {\n      return 'week';\n    }\n\n    if (duration.asMonths() < 18) {\n      return 'month';\n    }\n\n    if (duration.asYears() < 3) {\n      return 'quarter';\n    }\n\n    return 'year';\n  },\n\n  _isLoading() {\n    return !this.state.searchResult || !this.state.inputs || !this.state.streams || !this.state.nodes || !this.state.fields || !this.state.histogram;\n  },\n\n  render() {\n    if (this.state.error) {\n      let errorPage;\n      switch (this.state.error.status) {\n        case 400:\n          errorPage = <MalformedSearchQuery error={this.state.error} />;\n          break;\n        default:\n          errorPage = <SearchExecutionError error={this.state.error} />;\n      }\n\n      return <DocumentTitle title=\"Search error\">{errorPage}</DocumentTitle>;\n    }\n\n    if (this._isLoading()) {\n      return <Spinner />;\n    }\n\n    const searchResult = this.state.searchResult;\n    searchResult.all_fields = this.state.fields;\n    return (\n      <DocumentTitle title=\"Search\">\n        <SearchResult query={SearchStore.originalQuery} page={SearchStore.page} builtQuery={searchResult.built_query}\n                      result={searchResult} histogram={this.state.histogram}\n                      formattedHistogram={this.state.histogram.histogram}\n                      streams={this.state.streams} inputs={this.state.inputs} nodes={Immutable.Map(this.state.nodes)}\n                      searchInStream={this.props.searchInStream} permissions={this.state.currentUser.permissions}\n                      searchConfig={this.props.searchConfig}\n                      loadingSearch={this.state.updatingSearch || this.state.updatingHistogram}\n                      forceFetch={this.props.forceFetch} />\n      </DocumentTitle>\n    );\n  },\n});\n\nexport default SearchPage;\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/SearchPage.jsx"],"sourceRoot":""}